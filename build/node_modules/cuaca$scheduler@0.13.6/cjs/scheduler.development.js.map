{"version":3,"sources":["scheduler.development.js"],"names":["Object","defineProperty","exports","value","enableSchedulerDebugging","ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","firstCallbackNode","currentDidTimeout","isSchedulerPaused","currentPriorityLevel","currentEventStartTime","currentExpirationTime","isExecutingCallback","isHostCallbackScheduled","hasNativePerformanceNow","performance","now","ensureHostCallbackIsScheduled","expirationTime","cancelHostCallback","requestHostCallback","flushWork","flushFirstCallback","flushedNode","next","lastCallbackNode","previous","callback","priorityLevel","previousPriorityLevel","previousExpirationTime","continuationCallback","continuationNode","nextAfterContinuation","node","flushImmediateWork","didTimeout","previousDidTimeout","currentTime","unstable_now","shouldYieldToHost","unstable_runWithPriority","eventHandler","previousEventStartTime","unstable_next","unstable_wrapCallback","parentPriorityLevel","apply","arguments","unstable_scheduleCallback","deprecated_options","startTime","timeout","newNode","unstable_continueExecution","unstable_getFirstCallbackNode","unstable_cancelCallback","callbackNode","unstable_getCurrentPriorityLevel","unstable_shouldYield","localDate","Date","localSetTimeout","setTimeout","undefined","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","rAFID","rAFTimeoutID","requestAnimationFrameWithTimeout","timestamp","Performance","globalValue","window","global","_schedMock","globalImpl","MessageChannel","_callback","_flushCallback","cb","ms","console","error","scheduledHostCallback","isMessageEventScheduled","timeoutTime","isAnimationFrameScheduled","isFlushingHostCallback","frameDeadline","previousFrameTime","activeFrameTime","channel","port","port2","port1","onmessage","event","prevScheduledCallback","prevTimeoutTime","animationTick","rafTime","nextFrameTime","postMessage","absoluteTimeout","unstable_ImmediatePriority","unstable_UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority","unstable_LowPriority","unstable_pauseExecution"],"mappings":"AAAA;;;;;;;;;AASA;;;;;AAKE,GAAC,YAAW;AACd;;AAEAA,WAAOC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C,EAAEC,OAAO,IAAT,EAA7C;;AAEA,QAAIC,2BAA2B,KAA/B;;AAEA;;AAEA;AACA,QAAIC,oBAAoB,CAAxB;AACA,QAAIC,uBAAuB,CAA3B;AACA,QAAIC,iBAAiB,CAArB;AACA,QAAIC,cAAc,CAAlB;AACA,QAAIC,eAAe,CAAnB;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAIA;;;AAGA;AACA,QAAIC,oBAAoB,IAAxB;;AAEA,QAAIC,oBAAoB,KAAxB;AACA;AACA,QAAIC,oBAAoB,KAAxB;;AAEA,QAAIC,uBAAuBN,cAA3B;AACA,QAAIO,wBAAwB,CAAC,CAA7B;AACA,QAAIC,wBAAwB,CAAC,CAA7B;;AAEA;AACA,QAAIC,sBAAsB,KAA1B;;AAEA,QAAIC,0BAA0B,KAA9B;;AAEA,QAAIC,0BAA0B,OAAOC,WAAP,KAAuB,QAAvB,IAAmC,OAAOA,YAAYC,GAAnB,KAA2B,UAA5F;;AAEA,aAASC,6BAAT,GAAyC;AACvC,UAAIL,mBAAJ,EAAyB;AACvB;AACA;AACD;AACD;AACA,UAAIM,iBAAiBZ,kBAAkBY,cAAvC;AACA,UAAI,CAACL,uBAAL,EAA8B;AAC5BA,kCAA0B,IAA1B;AACD,OAFD,MAEO;AACL;AACAM;AACD;AACDC,0BAAoBC,SAApB,EAA+BH,cAA/B;AACD;;AAED,aAASI,kBAAT,GAA8B;AAC5B,UAAIC,cAAcjB,iBAAlB;;AAEA;AACA;AACA,UAAIkB,OAAOlB,kBAAkBkB,IAA7B;AACA,UAAIlB,sBAAsBkB,IAA1B,EAAgC;AAC9B;AACAlB,4BAAoB,IAApB;AACAkB,eAAO,IAAP;AACD,OAJD,MAIO;AACL,YAAIC,mBAAmBnB,kBAAkBoB,QAAzC;AACApB,4BAAoBmB,iBAAiBD,IAAjB,GAAwBA,IAA5C;AACAA,aAAKE,QAAL,GAAgBD,gBAAhB;AACD;;AAEDF,kBAAYC,IAAZ,GAAmBD,YAAYG,QAAZ,GAAuB,IAA1C;;AAEA;AACA,UAAIC,WAAWJ,YAAYI,QAA3B;AACA,UAAIT,iBAAiBK,YAAYL,cAAjC;AACA,UAAIU,gBAAgBL,YAAYK,aAAhC;AACA,UAAIC,wBAAwBpB,oBAA5B;AACA,UAAIqB,yBAAyBnB,qBAA7B;AACAF,6BAAuBmB,aAAvB;AACAjB,8BAAwBO,cAAxB;AACA,UAAIa,oBAAJ;AACA,UAAI;AACFA,+BAAuBJ,UAAvB;AACD,OAFD,SAEU;AACRlB,+BAAuBoB,qBAAvB;AACAlB,gCAAwBmB,sBAAxB;AACD;;AAED;AACA;AACA,UAAI,OAAOC,oBAAP,KAAgC,UAApC,EAAgD;AAC9C,YAAIC,mBAAmB;AACrBL,oBAAUI,oBADW;AAErBH,yBAAeA,aAFM;AAGrBV,0BAAgBA,cAHK;AAIrBM,gBAAM,IAJe;AAKrBE,oBAAU;AALW,SAAvB;;AAQA;AACA;AACA;AACA;AACA,YAAIpB,sBAAsB,IAA1B,EAAgC;AAC9B;AACAA,8BAAoB0B,iBAAiBR,IAAjB,GAAwBQ,iBAAiBN,QAAjB,GAA4BM,gBAAxE;AACD,SAHD,MAGO;AACL,cAAIC,wBAAwB,IAA5B;AACA,cAAIC,OAAO5B,iBAAX;AACA,aAAG;AACD,gBAAI4B,KAAKhB,cAAL,IAAuBA,cAA3B,EAA2C;AACzC;AACA;AACAe,sCAAwBC,IAAxB;AACA;AACD;AACDA,mBAAOA,KAAKV,IAAZ;AACD,WARD,QAQSU,SAAS5B,iBARlB;;AAUA,cAAI2B,0BAA0B,IAA9B,EAAoC;AAClC;AACA;AACAA,oCAAwB3B,iBAAxB;AACD,WAJD,MAIO,IAAI2B,0BAA0B3B,iBAA9B,EAAiD;AACtD;AACAA,gCAAoB0B,gBAApB;AACAf;AACD;;AAED,cAAIS,WAAWO,sBAAsBP,QAArC;AACAA,mBAASF,IAAT,GAAgBS,sBAAsBP,QAAtB,GAAiCM,gBAAjD;AACAA,2BAAiBR,IAAjB,GAAwBS,qBAAxB;AACAD,2BAAiBN,QAAjB,GAA4BA,QAA5B;AACD;AACF;AACF;;AAED,aAASS,kBAAT,GAA8B;AAC5B;AACA;AACAzB,gCAA0B,CAAC,CAA3B,IAAgCJ,sBAAsB,IAAtD,IAA8DA,kBAAkBsB,aAAlB,KAAoC3B,iBAFlG,EAEqH;AACnHW,8BAAsB,IAAtB;AACA,YAAI;AACF,aAAG;AACDU;AACD,WAFD;AAGA;AACAhB,gCAAsB,IAAtB,IAA8BA,kBAAkBsB,aAAlB,KAAoC3B,iBAJlE;AAKD,SAND,SAMU;AACRW,gCAAsB,KAAtB;AACA,cAAIN,sBAAsB,IAA1B,EAAgC;AAC9B;AACAW;AACD,WAHD,MAGO;AACLJ,sCAA0B,KAA1B;AACD;AACF;AACF;AACF;;AAED,aAASQ,SAAT,CAAmBe,UAAnB,EAA+B;;AAO7BxB,4BAAsB,IAAtB;AACA,UAAIyB,qBAAqB9B,iBAAzB;AACAA,0BAAoB6B,UAApB;AACA,UAAI;AACF,YAAIA,UAAJ,EAAgB;AACd;AACA,iBAAO9B,sBAAsB,IAAtB,IAA8B,EAAEN,4BAA4BQ,iBAA9B,CAArC,EAAuF;AACrF;AACA;AACA;AACA;AACA,gBAAI8B,cAAcxC,QAAQyC,YAAR,EAAlB;AACA,gBAAIjC,kBAAkBY,cAAlB,IAAoCoB,WAAxC,EAAqD;AACnD,iBAAG;AACDhB;AACD,eAFD,QAEShB,sBAAsB,IAAtB,IAA8BA,kBAAkBY,cAAlB,IAAoCoB,WAAlE,IAAiF,EAAEtC,4BAA4BQ,iBAA9B,CAF1F;AAGA;AACD;AACD;AACD;AACF,SAhBD,MAgBO;AACL;AACA,cAAIF,sBAAsB,IAA1B,EAAgC;AAC9B,eAAG;AAIDgB;AACD,aALD,QAKShB,sBAAsB,IAAtB,IAA8B,CAACkC,mBALxC;AAMD;AACF;AACF,OA5BD,SA4BU;AACR5B,8BAAsB,KAAtB;AACAL,4BAAoB8B,kBAApB;AACA,YAAI/B,sBAAsB,IAA1B,EAAgC;AAC9B;AACAW;AACD,SAHD,MAGO;AACLJ,oCAA0B,KAA1B;AACD;AACD;AACAsB;AACD;AACF;;AAED,aAASM,wBAAT,CAAkCb,aAAlC,EAAiDc,YAAjD,EAA+D;AAC7D,cAAQd,aAAR;AACE,aAAK3B,iBAAL;AACA,aAAKC,oBAAL;AACA,aAAKC,cAAL;AACA,aAAKC,WAAL;AACA,aAAKC,YAAL;AACE;AACF;AACEuB,0BAAgBzB,cAAhB;AARJ;;AAWA,UAAI0B,wBAAwBpB,oBAA5B;AACA,UAAIkC,yBAAyBjC,qBAA7B;AACAD,6BAAuBmB,aAAvB;AACAlB,8BAAwBZ,QAAQyC,YAAR,EAAxB;;AAEA,UAAI;AACF,eAAOG,cAAP;AACD,OAFD,SAEU;AACRjC,+BAAuBoB,qBAAvB;AACAnB,gCAAwBiC,sBAAxB;;AAEA;AACAR;AACD;AACF;;AAED,aAASS,aAAT,CAAuBF,YAAvB,EAAqC;AACnC,UAAId,gBAAgB,KAAK,CAAzB;AACA,cAAQnB,oBAAR;AACE,aAAKR,iBAAL;AACA,aAAKC,oBAAL;AACA,aAAKC,cAAL;AACE;AACAyB,0BAAgBzB,cAAhB;AACA;AACF;AACE;AACAyB,0BAAgBnB,oBAAhB;AACA;AAVJ;;AAaA,UAAIoB,wBAAwBpB,oBAA5B;AACA,UAAIkC,yBAAyBjC,qBAA7B;AACAD,6BAAuBmB,aAAvB;AACAlB,8BAAwBZ,QAAQyC,YAAR,EAAxB;;AAEA,UAAI;AACF,eAAOG,cAAP;AACD,OAFD,SAEU;AACRjC,+BAAuBoB,qBAAvB;AACAnB,gCAAwBiC,sBAAxB;;AAEA;AACAR;AACD;AACF;;AAED,aAASU,qBAAT,CAA+BlB,QAA/B,EAAyC;AACvC,UAAImB,sBAAsBrC,oBAA1B;AACA,aAAO,YAAY;AACjB;AACA,YAAIoB,wBAAwBpB,oBAA5B;AACA,YAAIkC,yBAAyBjC,qBAA7B;AACAD,+BAAuBqC,mBAAvB;AACApC,gCAAwBZ,QAAQyC,YAAR,EAAxB;;AAEA,YAAI;AACF,iBAAOZ,SAASoB,KAAT,CAAe,IAAf,EAAqBC,SAArB,CAAP;AACD,SAFD,SAEU;AACRvC,iCAAuBoB,qBAAvB;AACAnB,kCAAwBiC,sBAAxB;AACAR;AACD;AACF,OAdD;AAeD;;AAED,aAASc,yBAAT,CAAmCtB,QAAnC,EAA6CuB,kBAA7C,EAAiE;AAC/D,UAAIC,YAAYzC,0BAA0B,CAAC,CAA3B,GAA+BA,qBAA/B,GAAuDZ,QAAQyC,YAAR,EAAvE;;AAEA,UAAIrB,cAAJ;AACA,UAAI,OAAOgC,kBAAP,KAA8B,QAA9B,IAA0CA,uBAAuB,IAAjE,IAAyE,OAAOA,mBAAmBE,OAA1B,KAAsC,QAAnH,EAA6H;AAC3H;AACAlC,yBAAiBiC,YAAYD,mBAAmBE,OAAhD;AACD,OAHD,MAGO;AACL,gBAAQ3C,oBAAR;AACE,eAAKR,iBAAL;AACEiB,6BAAiBiC,YAhSQ,CAAC,CAgS1B;AACA;AACF,eAAKjD,oBAAL;AACEgB,6BAAiBiC,YAjSI,GAiSrB;AACA;AACF,eAAK9C,YAAL;AACEa,6BAAiBiC,YAzSD,UAyShB;AACA;AACF,eAAK/C,WAAL;AACEc,6BAAiBiC,YArSE,KAqSnB;AACA;AACF,eAAKhD,cAAL;AACA;AACEe,6BAAiBiC,YA1SK,IA0StB;AAfJ;AAiBD;;AAED,UAAIE,UAAU;AACZ1B,kBAAUA,QADE;AAEZC,uBAAenB,oBAFH;AAGZS,wBAAgBA,cAHJ;AAIZM,cAAM,IAJM;AAKZE,kBAAU;AALE,OAAd;;AAQA;AACA;AACA;AACA,UAAIpB,sBAAsB,IAA1B,EAAgC;AAC9B;AACAA,4BAAoB+C,QAAQ7B,IAAR,GAAe6B,QAAQ3B,QAAR,GAAmB2B,OAAtD;AACApC;AACD,OAJD,MAIO;AACL,YAAIO,OAAO,IAAX;AACA,YAAIU,OAAO5B,iBAAX;AACA,WAAG;AACD,cAAI4B,KAAKhB,cAAL,GAAsBA,cAA1B,EAA0C;AACxC;AACAM,mBAAOU,IAAP;AACA;AACD;AACDA,iBAAOA,KAAKV,IAAZ;AACD,SAPD,QAOSU,SAAS5B,iBAPlB;;AASA,YAAIkB,SAAS,IAAb,EAAmB;AACjB;AACA;AACAA,iBAAOlB,iBAAP;AACD,SAJD,MAIO,IAAIkB,SAASlB,iBAAb,EAAgC;AACrC;AACAA,8BAAoB+C,OAApB;AACApC;AACD;;AAED,YAAIS,WAAWF,KAAKE,QAApB;AACAA,iBAASF,IAAT,GAAgBA,KAAKE,QAAL,GAAgB2B,OAAhC;AACAA,gBAAQ7B,IAAR,GAAeA,IAAf;AACA6B,gBAAQ3B,QAAR,GAAmBA,QAAnB;AACD;;AAED,aAAO2B,OAAP;AACD;;AAMD,aAASC,0BAAT,GAAsC;AACpC9C,0BAAoB,KAApB;AACA,UAAIF,sBAAsB,IAA1B,EAAgC;AAC9BW;AACD;AACF;;AAED,aAASsC,6BAAT,GAAyC;AACvC,aAAOjD,iBAAP;AACD;;AAED,aAASkD,uBAAT,CAAiCC,YAAjC,EAA+C;AAC7C,UAAIjC,OAAOiC,aAAajC,IAAxB;AACA,UAAIA,SAAS,IAAb,EAAmB;AACjB;AACA;AACD;;AAED,UAAIA,SAASiC,YAAb,EAA2B;AACzB;AACAnD,4BAAoB,IAApB;AACD,OAHD,MAGO;AACL;AACA,YAAImD,iBAAiBnD,iBAArB,EAAwC;AACtCA,8BAAoBkB,IAApB;AACD;AACD,YAAIE,WAAW+B,aAAa/B,QAA5B;AACAA,iBAASF,IAAT,GAAgBA,IAAhB;AACAA,aAAKE,QAAL,GAAgBA,QAAhB;AACD;;AAED+B,mBAAajC,IAAb,GAAoBiC,aAAa/B,QAAb,GAAwB,IAA5C;AACD;;AAED,aAASgC,gCAAT,GAA4C;AAC1C,aAAOjD,oBAAP;AACD;;AAED,aAASkD,oBAAT,GAAgC;AAC9B,aAAO,CAACpD,iBAAD,KAAuBD,sBAAsB,IAAtB,IAA8BA,kBAAkBY,cAAlB,GAAmCP,qBAAjE,IAA0F6B,mBAAjH,CAAP;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAIoB,YAAYC,IAAhB;;AAEA;AACA;AACA;AACA;AACA,QAAIC,kBAAkB,OAAOC,UAAP,KAAsB,UAAtB,GAAmCA,UAAnC,GAAgDC,SAAtE;AACA,QAAIC,oBAAoB,OAAOC,YAAP,KAAwB,UAAxB,GAAqCA,YAArC,GAAoDF,SAA5E;;AAEA;AACA;AACA,QAAIG,6BAA6B,OAAOC,qBAAP,KAAiC,UAAjC,GAA8CA,qBAA9C,GAAsEJ,SAAvG;AACA,QAAIK,4BAA4B,OAAOC,oBAAP,KAAgC,UAAhC,GAA6CA,oBAA7C,GAAoEN,SAApG;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAIO,KAAJ;AACA,QAAIC,YAAJ;AACA,QAAIC,mCAAmC,UAAU9C,QAAV,EAAoB;AACzD;AACA4C,cAAQJ,2BAA2B,UAAUO,SAAV,EAAqB;AACtD;AACAT,0BAAkBO,YAAlB;AACA7C,iBAAS+C,SAAT;AACD,OAJO,CAAR;AAKAF,qBAAeV,gBAAgB,YAAY;AACzC;AACAO,kCAA0BE,KAA1B;AACA5C,iBAAS7B,QAAQyC,YAAR,EAAT;AACD,OAJc,EAVa,GAUb,CAAf;AAKD,KAZD;;AAcA,QAAIzB,uBAAJ,EAA6B;AAC3B,UAAI6D,cAAc5D,WAAlB;AACAjB,cAAQyC,YAAR,GAAuB,YAAY;AACjC,eAAOoC,YAAY3D,GAAZ,EAAP;AACD,OAFD;AAGD,KALD,MAKO;AACLlB,cAAQyC,YAAR,GAAuB,YAAY;AACjC,eAAOqB,UAAU5C,GAAV,EAAP;AACD,OAFD;AAGD;;AAED,QAAII,mBAAJ;AACA,QAAID,kBAAJ;AACA,QAAIqB,iBAAJ;;AAEA,QAAIoC,cAAc,IAAlB;AACA,QAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;AACjCD,oBAAcC,MAAd;AACD,KAFD,MAEO,IAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;AACxCF,oBAAcE,MAAd;AACD;;AAED,QAAIF,eAAeA,YAAYG,UAA/B,EAA2C;AACzC;AACA,UAAIC,aAAaJ,YAAYG,UAA7B;AACA3D,4BAAsB4D,WAAW,CAAX,CAAtB;AACA7D,2BAAqB6D,WAAW,CAAX,CAArB;AACAxC,0BAAoBwC,WAAW,CAAX,CAApB;AACAlF,cAAQyC,YAAR,GAAuByC,WAAW,CAAX,CAAvB;AACD,KAPD,MAOO;AACP;AACA;AACA,WAAOH,MAAP,KAAkB,WAAlB;AACA;AACA,WAAOI,cAAP,KAA0B,UALnB,EAK+B;AACpC;AACA;AACA,UAAIC,YAAY,IAAhB;AACA,UAAIC,iBAAiB,UAAU/C,UAAV,EAAsB;AACzC,YAAI8C,cAAc,IAAlB,EAAwB;AACtB,cAAI;AACFA,sBAAU9C,UAAV;AACD,WAFD,SAEU;AACR8C,wBAAY,IAAZ;AACD;AACF;AACF,OARD;AASA9D,4BAAsB,UAAUgE,EAAV,EAAcC,EAAd,EAAkB;AACtC,YAAIH,cAAc,IAAlB,EAAwB;AACtB;AACAnB,qBAAW3C,mBAAX,EAAgC,CAAhC,EAAmCgE,EAAnC;AACD,SAHD,MAGO;AACLF,sBAAYE,EAAZ;AACArB,qBAAWoB,cAAX,EAA2B,CAA3B,EAA8B,KAA9B;AACD;AACF,OARD;AASAhE,2BAAqB,YAAY;AAC/B+D,oBAAY,IAAZ;AACD,OAFD;AAGA1C,0BAAoB,YAAY;AAC9B,eAAO,KAAP;AACD,OAFD;AAGD,KAjCM,MAiCA;AACL,UAAI,OAAO8C,OAAP,KAAmB,WAAvB,EAAoC;AAClC;AACA,YAAI,OAAOnB,0BAAP,KAAsC,UAA1C,EAAsD;AACpDmB,kBAAQC,KAAR,CAAc,yDAAyD,4BAAzD,GAAwF,2DAAtG;AACD;AACD,YAAI,OAAOlB,yBAAP,KAAqC,UAAzC,EAAqD;AACnDiB,kBAAQC,KAAR,CAAc,wDAAwD,4BAAxD,GAAuF,2DAArG;AACD;AACF;;AAED,UAAIC,wBAAwB,IAA5B;AACA,UAAIC,0BAA0B,KAA9B;AACA,UAAIC,cAAc,CAAC,CAAnB;;AAEA,UAAIC,4BAA4B,KAAhC;;AAEA,UAAIC,yBAAyB,KAA7B;;AAEA,UAAIC,gBAAgB,CAApB;AACA;AACA;AACA;AACA,UAAIC,oBAAoB,EAAxB;AACA,UAAIC,kBAAkB,EAAtB;;AAEAvD,0BAAoB,YAAY;AAC9B,eAAOqD,iBAAiB/F,QAAQyC,YAAR,EAAxB;AACD,OAFD;;AAIA;AACA,UAAIyD,UAAU,IAAIf,cAAJ,EAAd;AACA,UAAIgB,OAAOD,QAAQE,KAAnB;AACAF,cAAQG,KAAR,CAAcC,SAAd,GAA0B,UAAUC,KAAV,EAAiB;AACzCZ,kCAA0B,KAA1B;;AAEA,YAAIa,wBAAwBd,qBAA5B;AACA,YAAIe,kBAAkBb,WAAtB;AACAF,gCAAwB,IAAxB;AACAE,sBAAc,CAAC,CAAf;;AAEA,YAAIpD,cAAcxC,QAAQyC,YAAR,EAAlB;;AAEA,YAAIH,aAAa,KAAjB;AACA,YAAIyD,gBAAgBvD,WAAhB,IAA+B,CAAnC,EAAsC;AACpC;AACA;AACA,cAAIiE,oBAAoB,CAAC,CAArB,IAA0BA,mBAAmBjE,WAAjD,EAA8D;AAC5D;AACA;AACAF,yBAAa,IAAb;AACD,WAJD,MAIO;AACL;AACA,gBAAI,CAACuD,yBAAL,EAAgC;AAC9B;AACAA,0CAA4B,IAA5B;AACAlB,+CAAiC+B,aAAjC;AACD;AACD;AACAhB,oCAAwBc,qBAAxB;AACAZ,0BAAca,eAAd;AACA;AACD;AACF;;AAED,YAAID,0BAA0B,IAA9B,EAAoC;AAClCV,mCAAyB,IAAzB;AACA,cAAI;AACFU,kCAAsBlE,UAAtB;AACD,WAFD,SAEU;AACRwD,qCAAyB,KAAzB;AACD;AACF;AACF,OAxCD;;AA0CA,UAAIY,gBAAgB,UAAUC,OAAV,EAAmB;AACrC,YAAIjB,0BAA0B,IAA9B,EAAoC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAf,2CAAiC+B,aAAjC;AACD,SAVD,MAUO;AACL;AACAb,sCAA4B,KAA5B;AACA;AACD;;AAED,YAAIe,gBAAgBD,UAAUZ,aAAV,GAA0BE,eAA9C;AACA,YAAIW,gBAAgBX,eAAhB,IAAmCD,oBAAoBC,eAA3D,EAA4E;AAC1E,cAAIW,gBAAgB,CAApB,EAAuB;AACrB;AACA;AACAA,4BAAgB,CAAhB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACAX,4BAAkBW,gBAAgBZ,iBAAhB,GAAoCA,iBAApC,GAAwDY,aAA1E;AACD,SAdD,MAcO;AACLZ,8BAAoBY,aAApB;AACD;AACDb,wBAAgBY,UAAUV,eAA1B;AACA,YAAI,CAACN,uBAAL,EAA8B;AAC5BA,oCAA0B,IAA1B;AACAQ,eAAKU,WAAL,CAAiB3C,SAAjB;AACD;AACF,OAxCD;;AA0CA5C,4BAAsB,UAAUO,QAAV,EAAoBiF,eAApB,EAAqC;AACzDpB,gCAAwB7D,QAAxB;AACA+D,sBAAckB,eAAd;AACA,YAAIhB,0BAA0BgB,kBAAkB,CAAhD,EAAmD;AACjD;AACAX,eAAKU,WAAL,CAAiB3C,SAAjB;AACD,SAHD,MAGO,IAAI,CAAC2B,yBAAL,EAAgC;AACrC;AACA;AACA;AACA;AACAA,sCAA4B,IAA5B;AACAlB,2CAAiC+B,aAAjC;AACD;AACF,OAdD;;AAgBArF,2BAAqB,YAAY;AAC/BqE,gCAAwB,IAAxB;AACAC,kCAA0B,KAA1B;AACAC,sBAAc,CAAC,CAAf;AACD,OAJD;AAKD;;AAED5F,YAAQ+G,0BAAR,GAAqC5G,iBAArC;AACAH,YAAQgH,6BAAR,GAAwC5G,oBAAxC;AACAJ,YAAQiH,uBAAR,GAAkC5G,cAAlC;AACAL,YAAQkH,qBAAR,GAAgC3G,YAAhC;AACAP,YAAQmH,oBAAR,GAA+B7G,WAA/B;AACAN,YAAQ2C,wBAAR,GAAmCA,wBAAnC;AACA3C,YAAQ8C,aAAR,GAAwBA,aAAxB;AACA9C,YAAQmD,yBAAR,GAAoCA,yBAApC;AACAnD,YAAQ0D,uBAAR,GAAkCA,uBAAlC;AACA1D,YAAQ+C,qBAAR,GAAgCA,qBAAhC;AACA/C,YAAQ4D,gCAAR,GAA2CA,gCAA3C;AACA5D,YAAQ6D,oBAAR,GAA+BA,oBAA/B;AACA7D,YAAQwD,0BAAR,GAAqCA,0BAArC;AACAxD,YAAQoH,uBAAR,GApTA,SAASA,uBAAT,GAAmC;AACjC1G,0BAAoB,IAApB;AACD,KAkTD;AACAV,YAAQyD,6BAAR,GAAwCA,6BAAxC;AACG,GA3qBD","file":"scheduler.development.js","sourcesContent":["/** @license React v0.13.6\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar enableSchedulerDebugging = false;\n\n/* eslint-disable no-var */\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\n// Times out immediately\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nvar USER_BLOCKING_PRIORITY = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nvar IDLE_PRIORITY = maxSigned31BitInt;\n\n// Callbacks are stored as a circular, doubly linked list.\nvar firstCallbackNode = null;\n\nvar currentDidTimeout = false;\n// Pausing the scheduler is useful for debugging.\nvar isSchedulerPaused = false;\n\nvar currentPriorityLevel = NormalPriority;\nvar currentEventStartTime = -1;\nvar currentExpirationTime = -1;\n\n// This is set when a callback is being executed, to prevent re-entrancy.\nvar isExecutingCallback = false;\n\nvar isHostCallbackScheduled = false;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nfunction ensureHostCallbackIsScheduled() {\n  if (isExecutingCallback) {\n    // Don't schedule work yet; wait until the next time we yield.\n    return;\n  }\n  // Schedule the host callback using the earliest expiration in the list.\n  var expirationTime = firstCallbackNode.expirationTime;\n  if (!isHostCallbackScheduled) {\n    isHostCallbackScheduled = true;\n  } else {\n    // Cancel the existing host callback.\n    cancelHostCallback();\n  }\n  requestHostCallback(flushWork, expirationTime);\n}\n\nfunction flushFirstCallback() {\n  var flushedNode = firstCallbackNode;\n\n  // Remove the node from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = firstCallbackNode.next;\n  if (firstCallbackNode === next) {\n    // This is the last callback in the list.\n    firstCallbackNode = null;\n    next = null;\n  } else {\n    var lastCallbackNode = firstCallbackNode.previous;\n    firstCallbackNode = lastCallbackNode.next = next;\n    next.previous = lastCallbackNode;\n  }\n\n  flushedNode.next = flushedNode.previous = null;\n\n  // Now it's safe to call the callback.\n  var callback = flushedNode.callback;\n  var expirationTime = flushedNode.expirationTime;\n  var priorityLevel = flushedNode.priorityLevel;\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousExpirationTime = currentExpirationTime;\n  currentPriorityLevel = priorityLevel;\n  currentExpirationTime = expirationTime;\n  var continuationCallback;\n  try {\n    continuationCallback = callback();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentExpirationTime = previousExpirationTime;\n  }\n\n  // A callback may return a continuation. The continuation should be scheduled\n  // with the same priority and expiration as the just-finished callback.\n  if (typeof continuationCallback === 'function') {\n    var continuationNode = {\n      callback: continuationCallback,\n      priorityLevel: priorityLevel,\n      expirationTime: expirationTime,\n      next: null,\n      previous: null\n    };\n\n    // Insert the new callback into the list, sorted by its expiration. This is\n    // almost the same as the code in `scheduleCallback`, except the callback\n    // is inserted into the list *before* callbacks of equal expiration instead\n    // of after.\n    if (firstCallbackNode === null) {\n      // This is the first callback in the list.\n      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n    } else {\n      var nextAfterContinuation = null;\n      var node = firstCallbackNode;\n      do {\n        if (node.expirationTime >= expirationTime) {\n          // This callback expires at or after the continuation. We will insert\n          // the continuation *before* this callback.\n          nextAfterContinuation = node;\n          break;\n        }\n        node = node.next;\n      } while (node !== firstCallbackNode);\n\n      if (nextAfterContinuation === null) {\n        // No equal or lower priority callback was found, which means the new\n        // callback is the lowest priority callback in the list.\n        nextAfterContinuation = firstCallbackNode;\n      } else if (nextAfterContinuation === firstCallbackNode) {\n        // The new callback is the highest priority callback in the list.\n        firstCallbackNode = continuationNode;\n        ensureHostCallbackIsScheduled();\n      }\n\n      var previous = nextAfterContinuation.previous;\n      previous.next = nextAfterContinuation.previous = continuationNode;\n      continuationNode.next = nextAfterContinuation;\n      continuationNode.previous = previous;\n    }\n  }\n}\n\nfunction flushImmediateWork() {\n  if (\n  // Confirm we've exited the outer most event handler\n  currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\n    isExecutingCallback = true;\n    try {\n      do {\n        flushFirstCallback();\n      } while (\n      // Keep flushing until there are no more immediate callbacks\n      firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\n    } finally {\n      isExecutingCallback = false;\n      if (firstCallbackNode !== null) {\n        // There's still work remaining. Request another callback.\n        ensureHostCallbackIsScheduled();\n      } else {\n        isHostCallbackScheduled = false;\n      }\n    }\n  }\n}\n\nfunction flushWork(didTimeout) {\n  // Exit right away if we're currently paused\n\n  if (enableSchedulerDebugging && isSchedulerPaused) {\n    return;\n  }\n\n  isExecutingCallback = true;\n  var previousDidTimeout = currentDidTimeout;\n  currentDidTimeout = didTimeout;\n  try {\n    if (didTimeout) {\n      // Flush all the expired callbacks without yielding.\n      while (firstCallbackNode !== null && !(enableSchedulerDebugging && isSchedulerPaused)) {\n        // TODO Wrap in feature flag\n        // Read the current time. Flush all the callbacks that expire at or\n        // earlier than that time. Then read the current time again and repeat.\n        // This optimizes for as few performance.now calls as possible.\n        var currentTime = exports.unstable_now();\n        if (firstCallbackNode.expirationTime <= currentTime) {\n          do {\n            flushFirstCallback();\n          } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused));\n          continue;\n        }\n        break;\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstCallbackNode !== null) {\n        do {\n          if (enableSchedulerDebugging && isSchedulerPaused) {\n            break;\n          }\n          flushFirstCallback();\n        } while (firstCallbackNode !== null && !shouldYieldToHost());\n      }\n    }\n  } finally {\n    isExecutingCallback = false;\n    currentDidTimeout = previousDidTimeout;\n    if (firstCallbackNode !== null) {\n      // There's still work remaining. Request another callback.\n      ensureHostCallbackIsScheduled();\n    } else {\n      isHostCallbackScheduled = false;\n    }\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousEventStartTime = currentEventStartTime;\n  currentPriorityLevel = priorityLevel;\n  currentEventStartTime = exports.unstable_now();\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentEventStartTime = previousEventStartTime;\n\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_next(eventHandler) {\n  var priorityLevel = void 0;\n  switch (currentPriorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n      // Shift down to normal priority\n      priorityLevel = NormalPriority;\n      break;\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousEventStartTime = currentEventStartTime;\n  currentPriorityLevel = priorityLevel;\n  currentEventStartTime = exports.unstable_now();\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentEventStartTime = previousEventStartTime;\n\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    var previousEventStartTime = currentEventStartTime;\n    currentPriorityLevel = parentPriorityLevel;\n    currentEventStartTime = exports.unstable_now();\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n      currentEventStartTime = previousEventStartTime;\n      flushImmediateWork();\n    }\n  };\n}\n\nfunction unstable_scheduleCallback(callback, deprecated_options) {\n  var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\n\n  var expirationTime;\n  if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\n    // FIXME: Remove this branch once we lift expiration times out of React.\n    expirationTime = startTime + deprecated_options.timeout;\n  } else {\n    switch (currentPriorityLevel) {\n      case ImmediatePriority:\n        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n        break;\n      case UserBlockingPriority:\n        expirationTime = startTime + USER_BLOCKING_PRIORITY;\n        break;\n      case IdlePriority:\n        expirationTime = startTime + IDLE_PRIORITY;\n        break;\n      case LowPriority:\n        expirationTime = startTime + LOW_PRIORITY_TIMEOUT;\n        break;\n      case NormalPriority:\n      default:\n        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n    }\n  }\n\n  var newNode = {\n    callback: callback,\n    priorityLevel: currentPriorityLevel,\n    expirationTime: expirationTime,\n    next: null,\n    previous: null\n  };\n\n  // Insert the new callback into the list, ordered first by expiration, then\n  // by insertion. So the new callback is inserted any other callback with\n  // equal expiration.\n  if (firstCallbackNode === null) {\n    // This is the first callback in the list.\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\n    ensureHostCallbackIsScheduled();\n  } else {\n    var next = null;\n    var node = firstCallbackNode;\n    do {\n      if (node.expirationTime > expirationTime) {\n        // The new callback expires before this one.\n        next = node;\n        break;\n      }\n      node = node.next;\n    } while (node !== firstCallbackNode);\n\n    if (next === null) {\n      // No callback with a later expiration was found, which means the new\n      // callback has the latest expiration in the list.\n      next = firstCallbackNode;\n    } else if (next === firstCallbackNode) {\n      // The new callback has the earliest expiration in the entire list.\n      firstCallbackNode = newNode;\n      ensureHostCallbackIsScheduled();\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newNode;\n    newNode.next = next;\n    newNode.previous = previous;\n  }\n\n  return newNode;\n}\n\nfunction unstable_pauseExecution() {\n  isSchedulerPaused = true;\n}\n\nfunction unstable_continueExecution() {\n  isSchedulerPaused = false;\n  if (firstCallbackNode !== null) {\n    ensureHostCallbackIsScheduled();\n  }\n}\n\nfunction unstable_getFirstCallbackNode() {\n  return firstCallbackNode;\n}\n\nfunction unstable_cancelCallback(callbackNode) {\n  var next = callbackNode.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (next === callbackNode) {\n    // This is the only scheduled callback. Clear the list.\n    firstCallbackNode = null;\n  } else {\n    // Remove the callback from its position in the list.\n    if (callbackNode === firstCallbackNode) {\n      firstCallbackNode = next;\n    }\n    var previous = callbackNode.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  callbackNode.next = callbackNode.previous = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nfunction unstable_shouldYield() {\n  return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());\n}\n\n// The remaining code is essentially a polyfill for requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated. We want to be using a\n// consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments if a component\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n// have setTimeout or clearTimeout. However, we always expect them to be defined\n// on the client. https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined, but we will error\n// later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n// requestAnimationFrame does not run when the tab is in the background. If\n// we're backgrounded we prefer for that work to happen so that the page\n// continues to load in the background. So we also schedule a 'setTimeout' as\n// a fallback.\n// TODO: Need a better heuristic for backgrounded work.\nvar ANIMATION_FRAME_TIMEOUT = 100;\nvar rAFID;\nvar rAFTimeoutID;\nvar requestAnimationFrameWithTimeout = function (callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function (timestamp) {\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function () {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nvar requestHostCallback;\nvar cancelHostCallback;\nvar shouldYieldToHost;\n\nvar globalValue = null;\nif (typeof window !== 'undefined') {\n  globalValue = window;\n} else if (typeof global !== 'undefined') {\n  globalValue = global;\n}\n\nif (globalValue && globalValue._schedMock) {\n  // Dynamic injection, only for testing purposes.\n  var globalImpl = globalValue._schedMock;\n  requestHostCallback = globalImpl[0];\n  cancelHostCallback = globalImpl[1];\n  shouldYieldToHost = globalImpl[2];\n  exports.unstable_now = globalImpl[3];\n} else if (\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\n// implementation using setTimeout.\ntypeof window === 'undefined' ||\n// Check if MessageChannel is supported, too.\ntypeof MessageChannel !== 'function') {\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n  // fallback to a naive implementation.\n  var _callback = null;\n  var _flushCallback = function (didTimeout) {\n    if (_callback !== null) {\n      try {\n        _callback(didTimeout);\n      } finally {\n        _callback = null;\n      }\n    }\n  };\n  requestHostCallback = function (cb, ms) {\n    if (_callback !== null) {\n      // Protect against re-entrancy.\n      setTimeout(requestHostCallback, 0, cb);\n    } else {\n      _callback = cb;\n      setTimeout(_flushCallback, 0, false);\n    }\n  };\n  cancelHostCallback = function () {\n    _callback = null;\n  };\n  shouldYieldToHost = function () {\n    return false;\n  };\n} else {\n  if (typeof console !== 'undefined') {\n    // TODO: Remove fb.me link\n    if (typeof localRequestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof localCancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var scheduledHostCallback = null;\n  var isMessageEventScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var isFlushingHostCallback = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  shouldYieldToHost = function () {\n    return frameDeadline <= exports.unstable_now();\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = function (event) {\n    isMessageEventScheduled = false;\n\n    var prevScheduledCallback = scheduledHostCallback;\n    var prevTimeoutTime = timeoutTime;\n    scheduledHostCallback = null;\n    timeoutTime = -1;\n\n    var currentTime = exports.unstable_now();\n\n    var didTimeout = false;\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n        // Exit without invoking the callback.\n        scheduledHostCallback = prevScheduledCallback;\n        timeoutTime = prevTimeoutTime;\n        return;\n      }\n    }\n\n    if (prevScheduledCallback !== null) {\n      isFlushingHostCallback = true;\n      try {\n        prevScheduledCallback(didTimeout);\n      } finally {\n        isFlushingHostCallback = false;\n      }\n    }\n  };\n\n  var animationTick = function (rafTime) {\n    if (scheduledHostCallback !== null) {\n      // Eagerly schedule the next animation callback at the beginning of the\n      // frame. If the scheduler queue is not empty at the end of the frame, it\n      // will continue flushing inside that callback. If the queue *is* empty,\n      // then it will exit immediately. Posting the callback at the start of the\n      // frame ensures it's fired within the earliest possible frame. If we\n      // waited until the end of the frame to post the callback, we risk the\n      // browser skipping a frame and not firing the callback until the frame\n      // after that.\n      requestAnimationFrameWithTimeout(animationTick);\n    } else {\n      // No pending work. Exit.\n      isAnimationFrameScheduled = false;\n      return;\n    }\n\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If the calculated frame time gets lower than 8, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isMessageEventScheduled) {\n      isMessageEventScheduled = true;\n      port.postMessage(undefined);\n    }\n  };\n\n  requestHostCallback = function (callback, absoluteTimeout) {\n    scheduledHostCallback = callback;\n    timeoutTime = absoluteTimeout;\n    if (isFlushingHostCallback || absoluteTimeout < 0) {\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\n      port.postMessage(undefined);\n    } else if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrameWithTimeout(animationTick);\n    }\n  };\n\n  cancelHostCallback = function () {\n    scheduledHostCallback = null;\n    isMessageEventScheduled = false;\n    timeoutTime = -1;\n  };\n}\n\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_LowPriority = LowPriority;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_next = unstable_next;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_wrapCallback = unstable_wrapCallback;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_shouldYield = unstable_shouldYield;\nexports.unstable_continueExecution = unstable_continueExecution;\nexports.unstable_pauseExecution = unstable_pauseExecution;\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n  })();\n}\n"]}