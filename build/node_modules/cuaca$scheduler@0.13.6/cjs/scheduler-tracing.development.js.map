{"version":3,"sources":["scheduler-tracing.development.js"],"names":["Object","defineProperty","exports","value","DEFAULT_THREAD_ID","interactionIDCounter","threadIDCounter","__interactionsRef","__subscriberRef","current","Set","unstable_getThreadID","unstable_trace","name","timestamp","callback","threadID","arguments","length","undefined","interaction","__count","id","prevInteractions","interactions","add","subscriber","returnValue","onInteractionTraced","onWorkStarted","onWorkStopped","onInteractionScheduledWorkCompleted","subscribers","unstable_subscribe","size","onWorkCanceled","onWorkScheduled","unstable_unsubscribe","delete","didCatchError","caughtError","forEach","error","unstable_clear","unstable_getCurrent","unstable_wrap","wrappedInteractions","hasRun","wrapped","apply","cancel"],"mappings":"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","file":"scheduler-tracing.development.js","sourcesContent":["/** @license React v0.13.6\n * scheduler-tracing.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\n\n\n// In some cases, StrictMode should also double-render lifecycles.\n// This can be confusing for tests though,\n// And it can be bad for performance in production.\n// This feature flag can be used to control the behavior:\n\n\n// To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\n\n\n// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\n\n\n// Gather advanced timing metrics for Profiler subtrees.\n\n\n// Trace which interactions trigger each commit.\nvar enableSchedulerTracing = true;\n\n// Only used in www builds.\n // TODO: true? Here it might just be false.\n\n// Only used in www builds.\n\n\n// Only used in www builds.\n\n\n// React Fire: prevent the value and checked attributes from syncing\n// with their related DOM properties\n\n\n// These APIs will no longer be \"unstable\" in the upcoming 16.7 release,\n// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.\n\nvar DEFAULT_THREAD_ID = 0;\n\n// Counters used to generate unique IDs.\nvar interactionIDCounter = 0;\nvar threadIDCounter = 0;\n\n// Set of currently traced interactions.\n// Interactions \"stack\"â€“\n// Meaning that newly traced interactions are appended to the previously active set.\n// When an interaction goes out of scope, the previous set (if any) is restored.\nexports.__interactionsRef = null;\n\n// Listener(s) to notify when interactions begin and end.\nexports.__subscriberRef = null;\n\nif (enableSchedulerTracing) {\n  exports.__interactionsRef = {\n    current: new Set()\n  };\n  exports.__subscriberRef = {\n    current: null\n  };\n}\n\nfunction unstable_clear(callback) {\n  if (!enableSchedulerTracing) {\n    return callback();\n  }\n\n  var prevInteractions = exports.__interactionsRef.current;\n  exports.__interactionsRef.current = new Set();\n\n  try {\n    return callback();\n  } finally {\n    exports.__interactionsRef.current = prevInteractions;\n  }\n}\n\nfunction unstable_getCurrent() {\n  if (!enableSchedulerTracing) {\n    return null;\n  } else {\n    return exports.__interactionsRef.current;\n  }\n}\n\nfunction unstable_getThreadID() {\n  return ++threadIDCounter;\n}\n\nfunction unstable_trace(name, timestamp, callback) {\n  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\n\n  if (!enableSchedulerTracing) {\n    return callback();\n  }\n\n  var interaction = {\n    __count: 1,\n    id: interactionIDCounter++,\n    name: name,\n    timestamp: timestamp\n  };\n\n  var prevInteractions = exports.__interactionsRef.current;\n\n  // Traced interactions should stack/accumulate.\n  // To do that, clone the current interactions.\n  // The previous set will be restored upon completion.\n  var interactions = new Set(prevInteractions);\n  interactions.add(interaction);\n  exports.__interactionsRef.current = interactions;\n\n  var subscriber = exports.__subscriberRef.current;\n  var returnValue = void 0;\n\n  try {\n    if (subscriber !== null) {\n      subscriber.onInteractionTraced(interaction);\n    }\n  } finally {\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkStarted(interactions, threadID);\n      }\n    } finally {\n      try {\n        returnValue = callback();\n      } finally {\n        exports.__interactionsRef.current = prevInteractions;\n\n        try {\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(interactions, threadID);\n          }\n        } finally {\n          interaction.__count--;\n\n          // If no async work was scheduled for this interaction,\n          // Notify subscribers that it's completed.\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        }\n      }\n    }\n  }\n\n  return returnValue;\n}\n\nfunction unstable_wrap(callback) {\n  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\n\n  if (!enableSchedulerTracing) {\n    return callback;\n  }\n\n  var wrappedInteractions = exports.__interactionsRef.current;\n\n  var subscriber = exports.__subscriberRef.current;\n  if (subscriber !== null) {\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\n  }\n\n  // Update the pending async work count for the current interactions.\n  // Update after calling subscribers in case of error.\n  wrappedInteractions.forEach(function (interaction) {\n    interaction.__count++;\n  });\n\n  var hasRun = false;\n\n  function wrapped() {\n    var prevInteractions = exports.__interactionsRef.current;\n    exports.__interactionsRef.current = wrappedInteractions;\n\n    subscriber = exports.__subscriberRef.current;\n\n    try {\n      var returnValue = void 0;\n\n      try {\n        if (subscriber !== null) {\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\n        }\n      } finally {\n        try {\n          returnValue = callback.apply(undefined, arguments);\n        } finally {\n          exports.__interactionsRef.current = prevInteractions;\n\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\n          }\n        }\n      }\n\n      return returnValue;\n    } finally {\n      if (!hasRun) {\n        // We only expect a wrapped function to be executed once,\n        // But in the event that it's executed more than onceâ€“\n        // Only decrement the outstanding interaction counts once.\n        hasRun = true;\n\n        // Update pending async counts for all wrapped interactions.\n        // If this was the last scheduled async work for any of them,\n        // Mark them as completed.\n        wrappedInteractions.forEach(function (interaction) {\n          interaction.__count--;\n\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        });\n      }\n    }\n  }\n\n  wrapped.cancel = function cancel() {\n    subscriber = exports.__subscriberRef.current;\n\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\n      }\n    } finally {\n      // Update pending async counts for all wrapped interactions.\n      // If this was the last scheduled async work for any of them,\n      // Mark them as completed.\n      wrappedInteractions.forEach(function (interaction) {\n        interaction.__count--;\n\n        if (subscriber && interaction.__count === 0) {\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\n        }\n      });\n    }\n  };\n\n  return wrapped;\n}\n\nvar subscribers = null;\nif (enableSchedulerTracing) {\n  subscribers = new Set();\n}\n\nfunction unstable_subscribe(subscriber) {\n  if (enableSchedulerTracing) {\n    subscribers.add(subscriber);\n\n    if (subscribers.size === 1) {\n      exports.__subscriberRef.current = {\n        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\n        onInteractionTraced: onInteractionTraced,\n        onWorkCanceled: onWorkCanceled,\n        onWorkScheduled: onWorkScheduled,\n        onWorkStarted: onWorkStarted,\n        onWorkStopped: onWorkStopped\n      };\n    }\n  }\n}\n\nfunction unstable_unsubscribe(subscriber) {\n  if (enableSchedulerTracing) {\n    subscribers.delete(subscriber);\n\n    if (subscribers.size === 0) {\n      exports.__subscriberRef.current = null;\n    }\n  }\n}\n\nfunction onInteractionTraced(interaction) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onInteractionTraced(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onInteractionScheduledWorkCompleted(interaction) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkScheduled(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkScheduled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStarted(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkStarted(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStopped(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkStopped(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkCanceled(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkCanceled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nexports.unstable_clear = unstable_clear;\nexports.unstable_getCurrent = unstable_getCurrent;\nexports.unstable_getThreadID = unstable_getThreadID;\nexports.unstable_trace = unstable_trace;\nexports.unstable_wrap = unstable_wrap;\nexports.unstable_subscribe = unstable_subscribe;\nexports.unstable_unsubscribe = unstable_unsubscribe;\n  })();\n}\n"]}